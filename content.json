{"meta":{"title":"黄凯阳的个人博客","subtitle":"随心呗","description":"我尽量一本正经的写代码","author":"黄凯阳","url":"http://huangkaiyang.cn"},"pages":[],"posts":[{"title":"基于javascript的对象继承","slug":"基于javascript的对象继承","date":"2018-01-23T09:32:19.000Z","updated":"2018-01-23T09:38:21.449Z","comments":true,"path":"front-end/基于javascript的对象继承.html","link":"","permalink":"http://huangkaiyang.cn/front-end/基于javascript的对象继承.html","excerpt":"","text":"谈到继承，javascript在ES6出现之前，是不提供原生的继承机制的，这里我们将通过几种方法，来实现功能上的继承。 1.基于原型链的继承1234567891011121314151617181920212223function SuperType()&#123; this.colors=[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;function SubType()&#123;&#125;SubType.prototype = new SuperType();SubType.prototype.getSuperValue = function()&#123; return this.subproperty;&#125;SubType.prototype.getSuperValue = function()&#123; return false;&#125;var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);var instance2 = new SubType();console.info(instance2.colors)result: [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;black&apos; ]console.info(instance1.hasOwnProperty(&quot;colors&quot;), &quot;colors&quot; in instance1)result: false true //说明colors这个属性不是子类的实例属性，而是原型属性 着重看第9行，子类的原型指向父类的实例，同样也就继承了父类实例后的所有属性，追着父类实例的原型链走，同样也继承到了父类的方法。 缺点：虽然得到了父类的属性和方法，但是都是在原型上的，当某一个实例对其属性进行更改时，会直接反应到原型上，如果这时实例化另外一个实例的话，就将接受这种更改，这往往是不能接受的，这在倒数。 2.借用构造函数来实现继承123456789101112131415function SuperType()&#123; this.colors=[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]&#125;function SubType()&#123; SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.info(instance1.colors) //red, blue, green, blackvar instance2 = new SubType();console.info(instance2.colors) //red, blue, greenconsole.info(instance1.hasOwnProperty(&quot;colors&quot;), &quot;colors&quot; in instance1)result: true true 着重看第五行，用了构造函数的call方法， call方法作用在与改变函数执行的作用域，第五行传入的this.也就是子类运行时的作用域，我们把子类作用域传入父类作用域，导致父类定义的那些属性会直接挂载到子类的作用域里，这个时候我们对子类进行实例化后得到的属性为实例属性。这个时候对各种对属性进行操作就不会影响到其他实例了。 缺点：如果方法也按照借用构造函数进行继承的话，那么方法他在每一个实例都会有一个拷贝，显然如果每个实例方法都是一样的话，会造成大量资源的浪费。 3.组合继承组合继承： 我们把想要继承的属性通过借用构造函数的方法，把方法通过原型链进行继承。12345678910111213141516171819202122232425262728function SuperType(name)&#123; this.name = name; this.colors=[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]&#125;SuperType.prototype.sayName = function()&#123; console.info(this.name);&#125;//借用构造函数完成属性的继承function SubType(name, age)&#123; SuperType.call(this, name); //添加公共属性 this.age = age; //添加自有属性&#125;//借用原型链实现方法的继承SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; console.info(this.age);&#125;var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);console.info(instance1.colors) //red, blue, green, blackinstance1.sayName(); //&quot;Nicholas&quot;instance1.sayAge() //29var instance2 = new SubType(&quot;Greg&quot;, 27);console.info(instance2.colors) //red, blue, greeninstance2.sayName() //&quot;Greg&quot;instance2.sayAge() //27 但是细心的你会发现我们在借用原型链实现方法的继承时，不仅把父类的方法挂载到原型上，父类的属性也挂载到了原型上，但是我们也借用构造函数实现实例属性的继承，而原则上是不需要挂载属性的，这就造成了原型上属性的冗余。 那么如何规避这种冗余呢？123456789101112131415161718192021222324252627282930313233function SuperType(name)&#123; this.name = name; this.colors=[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]&#125;SuperType.prototype.sayName = function()&#123; console.info(this.name);&#125;//借用构造函数完成属性的继承function SubType(name, age)&#123; SuperType.call(this, name); //添加公共属性 this.age = age; //添加自有属性&#125;//借用原型链实现方法的继承function F()&#123;&#125;//这样就只继承到了父类原型上的方法。F.prototype = SuperType.prototype;SubType.prototype = new F();// SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; console.info(this.age);&#125;var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);console.info(instance1.colors) //red, blue, green, blackinstance1.sayName(); //&quot;Nicholas&quot;instance1.sayAge() //29var instance2 = new SubType(&quot;Greg&quot;, 27);console.info(instance2.colors) //red, blue, greeninstance2.sayName() //&quot;Greg&quot;instance2.sayAge() //27 这是javascript实现继承的终极方法，很多流行的前端框架内部继承的实现也是基于这一方法的。","categories":[{"name":"前端","slug":"front-end","permalink":"http://huangkaiyang.cn/categories/front-end/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://huangkaiyang.cn/tags/javascript/"}]},{"title":"如何利用javascript创建对象","slug":"如何利用javascript创建对象","date":"2018-01-20T10:11:16.000Z","updated":"2018-01-20T10:19:14.223Z","comments":true,"path":"front-end/如何利用javascript创建对象.html","link":"","permalink":"http://huangkaiyang.cn/front-end/如何利用javascript创建对象.html","excerpt":"","text":"1.工厂模式工厂模式：通过函数和传递的参数创建一个包含参数信息的对象。考虑到ECMAScript2015之前不支持创建类，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节，如下面的代码所示。1234567891011function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; console.info(this.name); &#125;; return o;&#125;var person1 = createPerson(&apos;Nicholas&apos;, 29, &quot;softEngineer&quot;) 2.构造函数模式ECMAScript中的构造函数可用来创建特定类型的对象。此外也可以创建自定义的构造函数，从而定义自定义对象的属性和方法。例如，可以使用构造函数模式重写上面的例子。12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person1 = new Person(&apos;Nicholas&apos;, 29, &quot;softEngineer&quot;) 在这个例子里，我们没有在函数内部创建对象而是把属性和方法挂载到this上，并且无返回值。 重点是在我们实例这个构造函数调用new这个关键字的时候，其实我们做了如下四个步骤。 创建一个新对象。 将构造函数的作用域赋给新对象。与此同时，this也就指向了这个对象。 执行构造函数中的代码。 返回新对象 3.原型模式我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，也就是我们把我们想要的属性和方法挂载到了这个对象上。123456789101112function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.sayName = function()&#123; alert(this.name)&#125;var person1 = new Person();person1.sayName(); //Nicholasvar person2 = new Person();person2.sayName(); //Nicholas 很明显这样做的一个好处是所有对象实例都能共享原型上的属性和方法。 理解实例属性和原型属性hasOwnProperty:用来判断在实例好的对象上某一个属性或者方法是不是一个实例属性或者实例方法。也就是用来区分实例属性和原型属性。 4.组合使用构造函数模式和原型模式我们在上面提到了用构造函数模式和原型模式。构造函数模式用于定义实例属性，而原型模式用于定义共享的方法和属性，那么我们能不能将两者的优点结合起来，让属性实例，方法共享呢。因为往往不同实例的属性值是不一样的，而方法基本上都是相同的。这就是我们下面要讲到的组合模式。12345678910111213141516171819function Person()&#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;, &quot;Count&quot;];&#125;Person.prototype=&#123; constructor: Person, sayName:function()&#123; alert(this.name); &#125;&#125;var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;)person1.friends.push(&quot;Van&quot;)alert(person1.friends)alert(person2.friends)alert(person1.firends===person2.friends) //falsealert(person1.sayName === person2.sayName) //true 在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的。而修改了person1.friends,并不会影响到person2.friends。 —参考javascript高级程序设计（第三版）","categories":[{"name":"前端","slug":"front-end","permalink":"http://huangkaiyang.cn/categories/front-end/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://huangkaiyang.cn/tags/javascript/"}]},{"title":"深入理解javascript的对象属性——数据属性和访问器属性","slug":"深入理解javascript的对象属性——数据属性和访问器属性","date":"2018-01-20T10:00:44.000Z","updated":"2018-01-20T10:09:51.702Z","comments":true,"path":"front-end/深入理解javascript的对象属性——数据属性和访问器属性.html","link":"","permalink":"http://huangkaiyang.cn/front-end/深入理解javascript的对象属性——数据属性和访问器属性.html","excerpt":"","text":"关于定义一个对象上的属性，相信大家对这点并不陌生，一般的方法有以下三种。 123person.a= 1;person[&apos;a&apos;]= 1; person= &#123;a: 1&#125;; 那么定义javascript对象属性有哪些高级的方法呢，这是我们今天讨论的重点。ECMAScript有两种属性：数据属性和访问器属性。 数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值。是不是一脸懵逼，我们还是用例子来讲解吧。 12345678var person =&#123;&#125;Object.defineProperty(person, &quot;name&quot;, &#123; writable: false, value: &quot;Nicholas&quot;&#125;);alert(person.name); //&quot;Nicholas&quot;person.name= &quot;Greg&quot;;alert(person.name); //&quot;Nicholas&quot; 在上面的例子中，我们定义属性用了一个defineProperty的方法，这个方法是针对Object这个根对象进行调用的，而这个方法接收的第三个参数为我们上文提到的数据属性。是不是渐渐明白了。 数据属性有四个描述其行为的特性。Configurable: 表示能否通过delete删除属性从而重新定义属性，default为true。Enumerable: 表示能否通过for-in循环返回属性，default为true。Writable:表示能否修改属性的值，default为true。Value: 包含这个属性的数据值，default为undefined。 对于在一开始介绍的设置属性的一般方法它们的Configurable、Enumerable、Writable特性被设置为true, 而Value特性被设置为特定的值。 而在上面给出的例子中，writable被设置为false,所以我们在后面想要更改name的属性值发现是无法修改的。 访问器属性访问器属性和数据属性有什么区别呢，区别在与其属性不包含Writable,和Value,取而代之的是set和get。同样我们通过一个例子的深入理解。1234567891011121314151617 var book=&#123; _year: 2004, //私有属性 edition: 1 &#125;;;Object.defineProperty(book, &quot;year&quot;,&#123; //设置访问器属性 get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue&gt;2014)&#123; this._year = newValue; this.edition +=newValue-2014; &#125; &#125;&#125;);book.year = 2015;alert(book.edition); 很容易发现访问器属性在我们想要设置或者修改某个值得时候是非常有用的，并且可以通过他监听某个属性值是否发生了变化，这个最大的用途是在我们熟知的MVVM框架里头，利用界面和数据的绑定很快的让数据的改动体现在界面,很简单就是在set里面添加一个监听器，当一个属性发生变化后我们通知界面进行修改。 所以说访问器属性为我们后续的设计模式提供了一扇窗户。 —参考javascript高级程序设计（第三版）","categories":[{"name":"前端","slug":"front-end","permalink":"http://huangkaiyang.cn/categories/front-end/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://huangkaiyang.cn/tags/javascript/"}]},{"title":"基于javascript数组的栈方法和队列方法","slug":"基于javascript数组的栈方法和队列方法","date":"2018-01-18T04:32:44.000Z","updated":"2018-01-18T07:43:02.353Z","comments":true,"path":"front-end/基于javascript数组的栈方法和队列方法.html","link":"","permalink":"http://huangkaiyang.cn/front-end/基于javascript数组的栈方法和队列方法.html","excerpt":"","text":"栈和队列是我们常见的两种数据结构，今天我们讨论的是如何基于javascript数组来实现这种结构。 栈:简而言之就是先进后出。队列:先进先出数组作为javascript引用类型之一，天然提供了四个方法帮助我们实现栈和队列的结构。 shift: 从数组中把第一个元素删除，并返回被删除元素的值。pop:从数组中把最后一个元素删除，并返回被删除元素的值。unshift:在数组第一个元素之前增加元素，返回增加后数组的长度。push:在数组最后一个元素之后增加元素，返回增加后数组的长度。 栈：push + pop栈插入push12345 let a = [1,2,3] a.push(4) console.info(a)result:[1,2,3,4] 栈删除pop123456 let a = [1, 2, 3] a.push(4) a.pop() console.info(a)result:[1,2,3] 队列 unshift + pop 队列插入 unshift12345 let a = [1, 2, 3] a.unshift(4) console.info(a)result:[4,1,2,3] 队列删除 pop123456 let a = [1, 2, 3] a.unshift(4) a.pop() console.info(a)result:[4,1,2] 有关栈和队列的初步实现，就到这了。","categories":[{"name":"前端","slug":"front-end","permalink":"http://huangkaiyang.cn/categories/front-end/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://huangkaiyang.cn/tags/javascript/"}]},{"title":"CSS解决居中问题方案汇总","slug":"CSS解决居中问题方案汇总","date":"2018-01-17T11:59:53.000Z","updated":"2018-01-17T12:12:28.479Z","comments":true,"path":"front-end/CSS解决居中问题方案汇总.html","link":"","permalink":"http://huangkaiyang.cn/front-end/CSS解决居中问题方案汇总.html","excerpt":"","text":"CSS解决居中问题方案汇总 在你刚入前端之初，居中这个问题有时候会带给你一些烦恼，特别是垂直居中，这篇博客将从水平居中——垂直居中——整体居中方面提供全套解决方案。 注：着急看垂直居中或者整体居中可以直接往后翻 水平居中我们的需求是实现不定宽高的居中，初始代码如下12345&lt;div class=&quot;father&quot; style=&quot;background-color:aqua&quot;&gt; &lt;div class=&quot;child&quot; style=&quot;background-color: yellow&quot;&gt; 居中 &lt;/div&gt;&lt;/div&gt; 结果是这样的 很容易发现子元素占用了父元素的所有宽度。下面列出了三种水平居中的解决方案 1. text-align + inline-block1234567 .father&#123; text-align: center; &#125; .child&#123; display: inline-block; &#125;inline-block: 收敛子元素的宽度使其宽度随内容而定，text-align, 使收敛后的子元素居中 优点：兼容性好，除了IE6,7之外，基本上无兼容问题。缺点：text-align导致子元素内容也居中，这在某些情况下是不希望见到的。 2. table + margintable: 表面上像block，其实他的宽度是跟着内容走的于是乎我们可以这样12345.father&#123;&#125;.child&#123; display: table; margin: 0 auto;&#125; 结果是这样的优点：只作用父元素，兼容IE8及以上 3. relative + absolute这个不多说，相信大家平时用的也比较多12345678.father&#123; position: relative;&#125;.child&#123; position: absolute; left:50%; transform: translateX(-50%);&#125; 值得注意的是父元素相对定位后，其高度塌陷为0导致背景颜色无法显示，但居中目的确实是达到了。 4. flex + justifyFlex:牵涉到弹性盒子布局，如果对此不了解，很乐意当一个传送门Flexbox假定你已经了解了Flex或者看完了上述介绍，那我就直奔主题直接给出代码。12345.father&#123; display: flex; justify-content: center;&#125;.child&#123;&#125; 优点：简单缺点：兼容性，甚至在某些较新的非IE浏览器还依据需要加上厂商前缀 垂直居中相信你对vertical-align不陌生，听说可以使元素垂直居中，但为啥每次使用都没效果，在这说明一下，vertical-align只对inline, inline-block, table等级别元素有效，注意这里不包括block。好了，直奔主题。 1. table-cell + vertical1234.father&#123; display: table-cell; vertical-align: middle;&#125; 细心的你可能发现了子元素的宽度等同于父元素优点： 简单，只作用于父元素缺点： 除了很低版本的IE外，好像还真没啥 2. absolute + transform原理很简单，直接给出代码12345678.father&#123; position: relative;&#125;.child&#123; position: absolute; top:50%; transform: translateY(-50%);&#125; 这个刚好子元素的宽度为其内容宽度。缺点：兼容问题 详查Can I use? 3. flex + align-items不多说，你都看到这里,这就不是问题了，什么你真是跳着看的，好吧，再次勉为其难的送上一道传送门。Flex1234.father&#123; display: flex; align-items: center;&#125; 效果如上缺点：兼容问题 详查Can I use? 整体居中1. inline-block + text-align + table-cell + vertical思路很简单，先实现水平居中再实现垂直居中，你要反过来也可以。12345678.father&#123; text-align: center; display: table-cell; vertical-align: middle;&#125;.child&#123; display: inline-block;&#125; 2. absolute + transform123456789.father&#123; position: relative;&#125;.child&#123; position: absolute; top:50%; left:50%; transform: translate(-50%,-50%);&#125; 3. flex + justify + align-items12345.father&#123; display: flex; justify-content: center; align-items: center;&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"http://huangkaiyang.cn/categories/front-end/"}],"tags":[{"name":"css","slug":"css","permalink":"http://huangkaiyang.cn/tags/css/"}]}]}