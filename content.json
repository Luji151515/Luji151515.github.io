{"meta":{"title":"黄凯阳的个人博客","subtitle":"随心呗","description":"我尽量一本正经的写代码","author":"黄凯阳","url":"http://huangkaiyang.cn"},"pages":[],"posts":[{"title":"基于javascript数组的栈方法和队列方法","slug":"基于javascript数组的栈方法和队列方法","date":"2018-01-18T04:32:44.000Z","updated":"2018-01-18T07:43:02.353Z","comments":true,"path":"front-end/基于javascript数组的栈方法和队列方法.html","link":"","permalink":"http://huangkaiyang.cn/front-end/基于javascript数组的栈方法和队列方法.html","excerpt":"","text":"栈和队列是我们常见的两种数据结构，今天我们讨论的是如何基于javascript数组来实现这种结构。 栈:简而言之就是先进后出。队列:先进先出数组作为javascript引用类型之一，天然提供了四个方法帮助我们实现栈和队列的结构。 shift: 从数组中把第一个元素删除，并返回被删除元素的值。pop:从数组中把最后一个元素删除，并返回被删除元素的值。unshift:在数组第一个元素之前增加元素，返回增加后数组的长度。push:在数组最后一个元素之后增加元素，返回增加后数组的长度。 栈：push + pop栈插入push12345 let a = [1,2,3] a.push(4) console.info(a)result:[1,2,3,4] 栈删除pop123456 let a = [1, 2, 3] a.push(4) a.pop() console.info(a)result:[1,2,3] 队列 unshift + pop 队列插入 unshift12345 let a = [1, 2, 3] a.unshift(4) console.info(a)result:[4,1,2,3] 队列删除 pop123456 let a = [1, 2, 3] a.unshift(4) a.pop() console.info(a)result:[4,1,2] 有关栈和队列的初步实现，就到这了。","categories":[{"name":"前端","slug":"front-end","permalink":"http://huangkaiyang.cn/categories/front-end/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://huangkaiyang.cn/tags/javascript/"}]},{"title":"CSS解决居中问题方案汇总","slug":"CSS解决居中问题方案汇总","date":"2018-01-17T11:59:53.000Z","updated":"2018-01-17T12:12:28.479Z","comments":true,"path":"front-end/CSS解决居中问题方案汇总.html","link":"","permalink":"http://huangkaiyang.cn/front-end/CSS解决居中问题方案汇总.html","excerpt":"","text":"CSS解决居中问题方案汇总 在你刚入前端之初，居中这个问题有时候会带给你一些烦恼，特别是垂直居中，这篇博客将从水平居中——垂直居中——整体居中方面提供全套解决方案。 注：着急看垂直居中或者整体居中可以直接往后翻 水平居中我们的需求是实现不定宽高的居中，初始代码如下12345&lt;div class=&quot;father&quot; style=&quot;background-color:aqua&quot;&gt; &lt;div class=&quot;child&quot; style=&quot;background-color: yellow&quot;&gt; 居中 &lt;/div&gt;&lt;/div&gt; 结果是这样的 很容易发现子元素占用了父元素的所有宽度。下面列出了三种水平居中的解决方案 1. text-align + inline-block1234567 .father&#123; text-align: center; &#125; .child&#123; display: inline-block; &#125;inline-block: 收敛子元素的宽度使其宽度随内容而定，text-align, 使收敛后的子元素居中 优点：兼容性好，除了IE6,7之外，基本上无兼容问题。缺点：text-align导致子元素内容也居中，这在某些情况下是不希望见到的。 2. table + margintable: 表面上像block，其实他的宽度是跟着内容走的于是乎我们可以这样12345.father&#123;&#125;.child&#123; display: table; margin: 0 auto;&#125; 结果是这样的优点：只作用父元素，兼容IE8及以上 3. relative + absolute这个不多说，相信大家平时用的也比较多12345678.father&#123; position: relative;&#125;.child&#123; position: absolute; left:50%; transform: translateX(-50%);&#125; 值得注意的是父元素相对定位后，其高度塌陷为0导致背景颜色无法显示，但居中目的确实是达到了。 4. flex + justifyFlex:牵涉到弹性盒子布局，如果对此不了解，很乐意当一个传送门Flexbox假定你已经了解了Flex或者看完了上述介绍，那我就直奔主题直接给出代码。12345.father&#123; display: flex; justify-content: center;&#125;.child&#123;&#125; 优点：简单缺点：兼容性，甚至在某些较新的非IE浏览器还依据需要加上厂商前缀 垂直居中相信你对vertical-align不陌生，听说可以使元素垂直居中，但为啥每次使用都没效果，在这说明一下，vertical-align只对inline, inline-block, table等级别元素有效，注意这里不包括block。好了，直奔主题。 1. table-cell + vertical1234.father&#123; display: table-cell; vertical-align: middle;&#125; 细心的你可能发现了子元素的宽度等同于父元素优点： 简单，只作用于父元素缺点： 除了很低版本的IE外，好像还真没啥 2. absolute + transform原理很简单，直接给出代码12345678.father&#123; position: relative;&#125;.child&#123; position: absolute; top:50%; transform: translateY(-50%);&#125; 这个刚好子元素的宽度为其内容宽度。缺点：兼容问题 详查Can I use? 3. flex + align-items不多说，你都看到这里,这就不是问题了，什么你真是跳着看的，好吧，再次勉为其难的送上一道传送门。Flex1234.father&#123; display: flex; align-items: center;&#125; 效果如上缺点：兼容问题 详查Can I use? 整体居中1. inline-block + text-align + table-cell + vertical思路很简单，先实现水平居中再实现垂直居中，你要反过来也可以。12345678.father&#123; text-align: center; display: table-cell; vertical-align: middle;&#125;.child&#123; display: inline-block;&#125; 2. absolute + transform123456789.father&#123; position: relative;&#125;.child&#123; position: absolute; top:50%; left:50%; transform: translate(-50%,-50%);&#125; 3. flex + justify + align-items12345.father&#123; display: flex; justify-content: center; align-items: center;&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"http://huangkaiyang.cn/categories/front-end/"}],"tags":[{"name":"css","slug":"css","permalink":"http://huangkaiyang.cn/tags/css/"}]}]}